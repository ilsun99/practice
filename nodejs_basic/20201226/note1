//* 객체 지향 프로그래밍 
// Object-Oriented Programming 
// <-> 절차 지향 프로그래밍 
// 좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임
// 로직을 상태와 행위로 이루어진 객체로 만드는 것 
// 이 객체들을 레고 블럭처럼 조립하여 하나의 프로그램을 만드는 것 
// 서로 연관되는 상태와 행위를 그루핑

// 프로그램이 커지고 기능이 많아지면 비슷한 로직끼리 모아놓고 싶어짐 
// 어지러운 프로그래밍을 해결하는 방법론 중 하나 
// 로직 = 변수와 메소드 
// 변수와 메소드를 그루핑하는 방법을 언어에서 제공 
// 이렇게 그루핑된 집단을 객체라고 하는 것 
// 본문의 객체 = 본문의 변수 + 메소드 
// 객체를 다른 사이트에서 가져다 쓸 수 있게 됨 -> 재활용성에 객체가 기여 

//* 문법과 설계 
// 객체지향 프로그래밍 교육은 크게 두 가지로 구분된다.
// 문법: 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것 
// 설계: 좋은 객체를 만드는 법, 설계를 잘 해야 함 
// 추상화: 현실을 간단하게 단순화, 해결해야할 문제를 소프트웨어적으로 단순화하여 만드는 행위
// 소프트웨어를 만드는 것은 복잡한 현실을 추상화하는 것 

//* 부품화 
// 객체를 만든다, 로직을 만든다는 것은 부품을 만드는 것이라고 생각하면 됨 
// 적합성을 찾는 것이 중요하다. 
// 메소드: 부품화의 예, 연관된 로직들을 결합해서 완제품을 만듦
// 이를 조합해서 독립된 프로그램을 만듦 
// -> 메소드는 기능별로 분류되어 있기 때문에 효율성이 높아진다. 
// 하지만 프로그램이 커지면서 메소드를 관리하는 것도 어려워져 객체지향 등장 
// 연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그루핑하는 것 

//* 은닉화, 캡슐화 
// 제대로된 부품은 그것이 어떻게 만들어졌는지 모르는 사람도 사용할 수 있어야 한다. 
// 내부 동작 방법을 케이스 안으로 숨기고 사용자에게는 부품의 사용법만을 노출 
// 이런 컨셉을 정보의 은닉화, 또는 캡슐화라고 한다.  
// 부품을 상ㅛㅇ하는 방법이 중요해진다. 

//* 인터페이스 
// 잘 만들어진 부품이라면 부품과 부품을 교환할 수 있어야 한다. 
// 모니터와 컴퓨터를 서로 교환할 수 있는 것은 케이블이 표준화되어 있기 때문 
// 각각의 부품은 정해진 표준에 따라 신호를 입출력한다. 
// 이때 연결점을 인터페이스라고 한다. 

